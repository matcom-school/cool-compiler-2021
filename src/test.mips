.data
Bool_parents: .word 1, 2, 0, 
Bool: .word Bool_parents, Object_abort, Object_copy, Object_type_name, 
Int_parents: .word 1, 3, 0, 
Int: .word Int_parents, Object_abort, Object_copy, Object_type_name, 
String_parents: .word 1, 4, 0, 
String: .word String_parents, Object_abort, Object_copy, Object_type_name, String_concat, String_length, String_substr, 
SELF_TYPE_parents: .word 1, 5, 0, 
SELF_TYPE: .word SELF_TYPE_parents, Object_abort, Object_copy, Object_type_name, 
Object_parents: .word 1, 0, 
Object: .word Object_parents, Object_abort, Object_copy, Object_type_name, 
IO_parents: .word 1, 6, 0, 
IO: .word IO_parents, Object_abort, Object_copy, Object_type_name, IO_in_int, IO_in_string, IO_out_int, IO_out_string, 
A_parents: .word 1, 7, 0, 
A: .word A_parents, Object_abort, Object_copy, Object_type_name, A_out_a, 
B_parents: .word 1, 7, 8, 0, 
B: .word B_parents, Object_abort, Object_copy, Object_type_name, A_out_a, B_out_b, 
C_parents: .word 1, 6, 9, 0, 
C: .word C_parents, Object_abort, Object_copy, Object_type_name, IO_in_int, IO_in_string, IO_out_int, IO_out_string, C_out_c, 
D_parents: .word 1, 6, 9, 10, 0, 
D: .word D_parents, Object_abort, Object_copy, Object_type_name, IO_in_int, IO_in_string, IO_out_int, IO_out_string, C_out_c, D_out_d, 
Main_parents: .word 1, 6, 11, 0, 
Main: .word Main_parents, Object_abort, Object_copy, Object_type_name, IO_in_int, IO_in_string, IO_out_int, IO_out_string, Main_main, 
string_0: .asciiz "A: Hello world\n"
string_1: .asciiz "B: Hello world\n"
string_2: .asciiz "C: Hello world\n"
string_3: .asciiz "D: Hello world\n"
string_4: .asciiz "Done.\n"

.text
.globl main
main:
#Parametro Return $ra en stackpoiner + 20
#Parametro self en stackpoiner + 16
addi $sp, $sp, -4          #Push local var instance stackpointer 12
addi $sp, $sp, -4          #Push local var type_name@0 stackpointer 8
addi $sp, $sp, -4          #Push local var @result stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_Main
#Allocate a una class Main puntero en sp + 12
#atributo @type en puntero + 0
#atributo type en puntero + 4
li $a0, 8
li $v0, 9
syscall
sw $v0, 12($sp)          #Reservando memoria para una instancia de tipo Main
la $t0, Main
sw $t0, 8($sp)          #Cargando el nombre del tipo desde el data
lw $t0, 12($sp)          #Buscando la instancia en la pila instance
lw $t1, 8($sp)          #Buscando el valor que se va a guardar en la propiedad
sw $t1, 0($t0)          #Seteando el valor en la direccion de la memoria del objeto          #Assignando el nombre del tipo en el campo type
lw $t0, 12($sp)          #Saca de la pila instance
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila instance
jal Main_main          #Call a la function Main_main
sw $s0, 4($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila
li $v0, 10
syscall

Main_main:
#Parametro Return $ra en stackpoiner + 48
#Parametro self en stackpoiner + 44
addi $sp, $sp, -4          #Push local var step@block@0 stackpointer 40
addi $sp, $sp, -4          #Push local var instance_to_call_out_a@0 stackpointer 36
addi $sp, $sp, -4          #Push local var step@block@1 stackpointer 32
addi $sp, $sp, -4          #Push local var instance_to_call_out_b@0 stackpointer 28
addi $sp, $sp, -4          #Push local var step@block@2 stackpointer 24
addi $sp, $sp, -4          #Push local var instance_to_call_out_c@0 stackpointer 20
addi $sp, $sp, -4          #Push local var step@block@3 stackpointer 16
addi $sp, $sp, -4          #Push local var instance_to_call_out_d@0 stackpointer 12
addi $sp, $sp, -4          #Push local var param_0_to_out_string@0 stackpointer 8
addi $sp, $sp, -4          #Push local var @result stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion Main_main          #Inicio de una secuencia Block          #Inicio del paso 0 de una sequencia Block
jal new_ctr_A          #Call a la function new_ctr_A
sw $s0, 36($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila          #Fin de la exprecion previa al Dispatch out_a
lw $t0, 36($sp)          #Saca de la pila instance_to_call_out_a@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila instance_to_call_out_a@0
lw $t0, 40($sp)          #Sacando la instancia de la pila (en 36) de una clase que hereda de A
lw $t1, 0($t0)          #Leyendo el tipo de la instancia que hereda de A
lw $t3, 16($t1)          #Buscando el metodo dinamico para la funcion out_a
jal $t3          #Call a la function $t3
sw $s0, 40($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila          #Inicio del paso 1 de una sequencia Block
jal new_ctr_B          #Call a la function new_ctr_B
sw $s0, 28($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila          #Fin de la exprecion previa al Dispatch out_b
lw $t0, 28($sp)          #Saca de la pila instance_to_call_out_b@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila instance_to_call_out_b@0
lw $t0, 32($sp)          #Sacando la instancia de la pila (en 28) de una clase que hereda de B
lw $t1, 0($t0)          #Leyendo el tipo de la instancia que hereda de B
lw $t3, 20($t1)          #Buscando el metodo dinamico para la funcion out_b
jal $t3          #Call a la function $t3
sw $s0, 32($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila          #Inicio del paso 2 de una sequencia Block
jal new_ctr_C          #Call a la function new_ctr_C
sw $s0, 20($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila          #Fin de la exprecion previa al Dispatch out_c
lw $t0, 20($sp)          #Saca de la pila instance_to_call_out_c@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila instance_to_call_out_c@0
lw $t0, 24($sp)          #Sacando la instancia de la pila (en 20) de una clase que hereda de C
lw $t1, 0($t0)          #Leyendo el tipo de la instancia que hereda de C
lw $t3, 32($t1)          #Buscando el metodo dinamico para la funcion out_c
jal $t3          #Call a la function $t3
sw $s0, 24($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila          #Inicio del paso 3 de una sequencia Block
jal new_ctr_D          #Call a la function new_ctr_D
sw $s0, 12($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila          #Fin de la exprecion previa al Dispatch out_d
lw $t0, 12($sp)          #Saca de la pila instance_to_call_out_d@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila instance_to_call_out_d@0
lw $t0, 16($sp)          #Sacando la instancia de la pila (en 12) de una clase que hereda de D
lw $t1, 0($t0)          #Leyendo el tipo de la instancia que hereda de D
lw $t3, 36($t1)          #Buscando el metodo dinamico para la funcion out_d
jal $t3          #Call a la function $t3
sw $s0, 16($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila          #Inicio del paso 4 de una sequencia Block
la $t0, string_4
sw $t0, 8($sp)          #Fin del paramentro 0 al StaticDispatch out_string
lw $t0, 44($sp)          #Saca de la pila self
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila self          #Agrega a la pila el paramentro 0 al StaticDispatch out_string
lw $t0, 12($sp)          #Saca de la pila param_0_to_out_string@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila param_0_to_out_string@0          #Agrega a la pila el paramentro 1 al StaticDispatch out_string
jal IO_out_string          #Call a la function IO_out_string
sw $s0, 4($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila
lw $s0, 4($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 48($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 52          #Limpia la pila
jr $ra          #Final de la function main

new_ctr_A:
#Parametro Return $ra en stackpoiner + 20
#Parametro self en stackpoiner + 16
addi $sp, $sp, -4          #Push local var instance stackpointer 12
addi $sp, $sp, -4          #Push local var type_name@0 stackpointer 8
addi $sp, $sp, -4          #Push local var io@0 stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_A
#Allocate a una class A puntero en sp + 12
#atributo @type en puntero + 0
#atributo type en puntero + 4
#atributo io en puntero + 8
li $a0, 12
li $v0, 9
syscall
sw $v0, 12($sp)          #Reservando memoria para una instancia de tipo A
la $t0, A
sw $t0, 8($sp)          #Cargando el nombre del tipo desde el data
lw $t0, 12($sp)          #Buscando la instancia en la pila instance
lw $t1, 8($sp)          #Buscando el valor que se va a guardar en la propiedad
sw $t1, 0($t0)          #Seteando el valor en la direccion de la memoria del objeto          #Assignando el nombre del tipo en el campo type
jal new_ctr_IO          #Call a la function new_ctr_IO
sw $s0, 4($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila
lw $t0, 12($sp)          #Buscando la instancia en la pila instance
lw $t1, 4($sp)          #Buscando el valor que se va a guardar en la propiedad
sw $t1, 8($t0)          #Seteando el valor en la direccion de la memoria del objeto          #Assignando el resultado de la expression al atributo io de la clase A
lw $s0, 12($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 20($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 24          #Limpia la pila
jr $ra

A_out_a:
#Parametro Return $ra en stackpoiner + 20
#Parametro self en stackpoiner + 16
addi $sp, $sp, -4          #Push local var instance_to_call_out_string@0 stackpointer 12
addi $sp, $sp, -4          #Push local var param_0_to_out_string@0 stackpointer 8
addi $sp, $sp, -4          #Push local var @result stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion A_out_a
lw $t0, 16($sp)          #Buscando la instancia de la clase A en la pila
lw $t1, 8($t0)          #Buscando el valor de la propiedad io
sw $t1, 12($sp)          #Salvando el valor de la propiedad io en la pila en el valor local instance_to_call_out_string@0          #Fin de la exprecion previa al Dispatch out_string
la $t0, string_0
sw $t0, 8($sp)          #Fin del paramentro 0 al Dispatch out_string
lw $t0, 12($sp)          #Saca de la pila instance_to_call_out_string@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila instance_to_call_out_string@0
lw $t0, 12($sp)          #Saca de la pila param_0_to_out_string@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila param_0_to_out_string@0
lw $t0, 20($sp)          #Sacando la instancia de la pila (en 12) de una clase que hereda de IO
lw $t1, 0($t0)          #Leyendo el tipo de la instancia que hereda de IO
lw $t3, 28($t1)          #Buscando el metodo dinamico para la funcion out_string
jal $t3          #Call a la function $t3
sw $s0, 4($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila
lw $s0, 4($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 20($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 24          #Limpia la pila
jr $ra          #Final de la function out_a

new_ctr_B:
#Parametro Return $ra en stackpoiner + 16
#Parametro self en stackpoiner + 12
addi $sp, $sp, -4          #Push local var instance stackpointer 8
addi $sp, $sp, -4          #Push local var type_name@0 stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_B
#Allocate a una class B puntero en sp + 8
#atributo @type en puntero + 0
#atributo type en puntero + 4
#atributo io en puntero + 8
li $a0, 12
li $v0, 9
syscall
sw $v0, 8($sp)          #Reservando memoria para una instancia de tipo B
la $t0, B
sw $t0, 4($sp)          #Cargando el nombre del tipo desde el data
lw $t0, 8($sp)          #Buscando la instancia en la pila instance
lw $t1, 4($sp)          #Buscando el valor que se va a guardar en la propiedad
sw $t1, 0($t0)          #Seteando el valor en la direccion de la memoria del objeto          #Assignando el nombre del tipo en el campo type
lw $s0, 8($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 16($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 20          #Limpia la pila
jr $ra

B_out_b:
#Parametro Return $ra en stackpoiner + 20
#Parametro self en stackpoiner + 16
addi $sp, $sp, -4          #Push local var instance_to_call_out_string@0 stackpointer 12
addi $sp, $sp, -4          #Push local var param_0_to_out_string@0 stackpointer 8
addi $sp, $sp, -4          #Push local var @result stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion B_out_b
lw $t0, 16($sp)          #Buscando la instancia de la clase A en la pila
lw $t1, 8($t0)          #Buscando el valor de la propiedad io
sw $t1, 12($sp)          #Salvando el valor de la propiedad io en la pila en el valor local instance_to_call_out_string@0          #Fin de la exprecion previa al Dispatch out_string
la $t0, string_1
sw $t0, 8($sp)          #Fin del paramentro 0 al Dispatch out_string
lw $t0, 12($sp)          #Saca de la pila instance_to_call_out_string@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila instance_to_call_out_string@0
lw $t0, 12($sp)          #Saca de la pila param_0_to_out_string@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila param_0_to_out_string@0
lw $t0, 20($sp)          #Sacando la instancia de la pila (en 12) de una clase que hereda de IO
lw $t1, 0($t0)          #Leyendo el tipo de la instancia que hereda de IO
lw $t3, 28($t1)          #Buscando el metodo dinamico para la funcion out_string
jal $t3          #Call a la function $t3
sw $s0, 4($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila
lw $s0, 4($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 20($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 24          #Limpia la pila
jr $ra          #Final de la function out_b

new_ctr_C:
#Parametro Return $ra en stackpoiner + 16
#Parametro self en stackpoiner + 12
addi $sp, $sp, -4          #Push local var instance stackpointer 8
addi $sp, $sp, -4          #Push local var type_name@0 stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_C
#Allocate a una class C puntero en sp + 8
#atributo @type en puntero + 0
#atributo type en puntero + 4
li $a0, 8
li $v0, 9
syscall
sw $v0, 8($sp)          #Reservando memoria para una instancia de tipo C
la $t0, C
sw $t0, 4($sp)          #Cargando el nombre del tipo desde el data
lw $t0, 8($sp)          #Buscando la instancia en la pila instance
lw $t1, 4($sp)          #Buscando el valor que se va a guardar en la propiedad
sw $t1, 0($t0)          #Seteando el valor en la direccion de la memoria del objeto          #Assignando el nombre del tipo en el campo type
lw $s0, 8($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 16($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 20          #Limpia la pila
jr $ra

C_out_c:
#Parametro Return $ra en stackpoiner + 16
#Parametro self en stackpoiner + 12
addi $sp, $sp, -4          #Push local var param_0_to_out_string@0 stackpointer 8
addi $sp, $sp, -4          #Push local var @result stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion C_out_c
la $t0, string_2
sw $t0, 8($sp)          #Fin del paramentro 0 al StaticDispatch out_string
lw $t0, 12($sp)          #Saca de la pila self
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila self          #Agrega a la pila el paramentro 0 al StaticDispatch out_string
lw $t0, 12($sp)          #Saca de la pila param_0_to_out_string@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila param_0_to_out_string@0          #Agrega a la pila el paramentro 1 al StaticDispatch out_string
jal IO_out_string          #Call a la function IO_out_string
sw $s0, 4($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila
lw $s0, 4($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 16($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 20          #Limpia la pila
jr $ra          #Final de la function out_c

new_ctr_D:
#Parametro Return $ra en stackpoiner + 16
#Parametro self en stackpoiner + 12
addi $sp, $sp, -4          #Push local var instance stackpointer 8
addi $sp, $sp, -4          #Push local var type_name@0 stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_D
#Allocate a una class D puntero en sp + 8
#atributo @type en puntero + 0
#atributo type en puntero + 4
li $a0, 8
li $v0, 9
syscall
sw $v0, 8($sp)          #Reservando memoria para una instancia de tipo D
la $t0, D
sw $t0, 4($sp)          #Cargando el nombre del tipo desde el data
lw $t0, 8($sp)          #Buscando la instancia en la pila instance
lw $t1, 4($sp)          #Buscando el valor que se va a guardar en la propiedad
sw $t1, 0($t0)          #Seteando el valor en la direccion de la memoria del objeto          #Assignando el nombre del tipo en el campo type
lw $s0, 8($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 16($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 20          #Limpia la pila
jr $ra

D_out_d:
#Parametro Return $ra en stackpoiner + 16
#Parametro self en stackpoiner + 12
addi $sp, $sp, -4          #Push local var param_0_to_out_string@0 stackpointer 8
addi $sp, $sp, -4          #Push local var @result stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion D_out_d
la $t0, string_3
sw $t0, 8($sp)          #Fin del paramentro 0 al StaticDispatch out_string
lw $t0, 12($sp)          #Saca de la pila self
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila self          #Agrega a la pila el paramentro 0 al StaticDispatch out_string
lw $t0, 12($sp)          #Saca de la pila param_0_to_out_string@0
addi $sp, $sp, -4
sw $t0, 0($sp)          #Mete para la pila param_0_to_out_string@0          #Agrega a la pila el paramentro 1 al StaticDispatch out_string
jal IO_out_string          #Call a la function IO_out_string
sw $s0, 4($sp)          #Save el resultado de la funcion que esta en $s0 pa la pila
lw $s0, 4($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 16($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 20          #Limpia la pila
jr $ra          #Final de la function out_d


IO_out_string:
li $v0, 4
lw $a0, 0($sp)
syscall
lw $a0, 4($sp)
addi $sp, $sp, 8
jr $ra
new_ctr_IO:
#Parametro Return $ra en stackpoiner + 16
#Parametro self en stackpoiner + 12
addi $sp, $sp, -4          #Push local var instance stackpointer 8
addi $sp, $sp, -4          #Push local var type_name@0 stackpointer 4
addi $sp, $sp, -4          #Push local var $ra stackpointer 0
sw $ra, 0($sp)          #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_IO
#Allocate a una class IO puntero en sp + 8
#atributo @type en puntero + 0
#atributo type en puntero + 4
li $a0, 8
li $v0, 9
syscall
sw $v0, 8($sp)          #Reservando memoria para una instancia de tipo IO
la $t0, IO
sw $t0, 4($sp)          #Cargando el nombre del tipo desde el data
lw $t0, 8($sp)          #Buscando la instancia en la pila instance
lw $t1, 4($sp)          #Buscando el valor que se va a guardar en la propiedad
sw $t1, 0($t0)          #Seteando el valor en la direccion de la memoria del objeto          #Assignando el nombre del tipo en el campo type
lw $s0, 8($sp)          #Envia el resultado de la funcion en $s0
lw $ra, 16($sp)          #Lee el $ra mas profundo de la pila para retornar a la funcion anterior
addi $sp, $sp, 20          #Limpia la pila
jr $ra

